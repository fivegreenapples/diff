// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package diff

// BoolPatch is a description of how to convert one input bool slice to a
// second bool slice. It is simply a slice of changeT structs.
type BoolPatch []BoolChange

// A BoolChange describes a single instance of a difference acting at a particular
// offset into the original bool slice. It details the offset, the new items to be
// added at this offset, and the number of items that should be skipped in the original
// slice.
type BoolChange struct {
	Offset int
	Add    []bool
	Skip   int
}

// MakeBoolPatch calculates the BoolPatch from a to b
func MakeBoolPatch(a, b []bool) BoolPatch {
	firstDiff, lcs := BoolLCS(a, b)

	indexA := firstDiff
	indexB := firstDiff
	indexCommon := firstDiff
	patch := BoolPatch{}

	for indexA < len(a) || indexB < len(b) {

		for indexA < len(a) && indexB < len(b) && a[indexA] == b[indexB] {
			indexA++
			indexB++
			indexCommon++
		}

		newChange := BoolChange{
			Offset: indexA,
		}

		for indexA < len(a) && (indexCommon >= len(lcs) || a[indexA] != lcs[indexCommon]) {
			newChange.Skip++
			indexA++
		}
		for indexB < len(b) && (indexCommon >= len(lcs) || b[indexB] != lcs[indexCommon]) {
			newChange.Add = append(newChange.Add, b[indexB])
			indexB++
		}

		patch = append(patch, newChange)
	}
	return patch
}

// ApplyBoolPatch creates a new slice given an input slice, a, and a BoolPatch p.
func ApplyBoolPatch(a []bool, p BoolPatch) []bool {

	result := []bool{}

	indexA := 0
	indexP := 0

	for indexP < len(p) || indexA < len(a) {
		if indexP < len(p) {
			currentChange := p[indexP]
			if currentChange.Offset == indexA {
				// Act on current change as we're at the right line number
				result = append(result, currentChange.Add...)
				indexA += currentChange.Skip
				indexP++
				continue
			} else if indexA >= len(a) {
				// this protects us from a duff patch where items in the patch
				// reference beyond the end of the original.
				break
			}
		}

		if indexA < len(a) {
			result = append(result, a[indexA])
			indexA++
		}
	}

	return result
}
